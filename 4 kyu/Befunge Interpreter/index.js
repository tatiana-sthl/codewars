/*
PSEUDOCODE
1. Write a function such that when you pass in the Befunge code, 
2. The function returns the output that would be generated by the code.
*/

function getInstructionsMatrix(code) {
  return code.split('\n').map(function(elem) {return elem.split('');});  
}

function interpret(code) {
  let instructions = getInstructionsMatrix(code);
  let xPointer = 0;
  let yPointer = 0;
  let currentInstruction;
  let stack = [];
  let direction = '>';
  let output = "";
  
  const moveRight = function() {
    if (xPointer < instructions[yPointer].length - 1) {
        xPointer++;
    } else {
      yPointer++;
      xPointer = 0;
    }
  }
  
  var moveLeft = function() {
    if (xPointer > 0) {
      xPointer--;
    } else {
      yPointer++;
      xPointer = instructions[yPointer].length - 1;
    }
  }
  
  const moveDown = function() {
    if (yPointer < instructions.length - 1) {
      yPointer++;
    } else {
      yPointer = 0;
      xPointer++;
    }
  }
  
  const moveUp = function() {
    if (yPointer > 0) {
      yPointer--;
    } else {
      yPointer = instructions.length - 1;
      xPointer = xPointer++;
    }
  } 
  
  let moveToNext = function() { movements[direction](); }
  
  const executeAndMove = function(f) {
    return function() {
      f && f();
      moveToNext();
    };
  }
  
  let push = function(elem) { stack.push(elem); }
  
  let pop = function() { return stack.pop(); }
  
  let processNumber = function(n) { return function(){ push(n); }; }
  
  let processPlus = function() {push(pop() + pop()); }
  
  let processMinus = function() {
    let a = pop();
    let b = pop();
    push(b-a);
  }
  
  let processTimes = function() { push(pop() * pop()); }
  
  const processDivision = function() {
    var a = pop();
    var b = pop();
    push(a ? Math.floor(b/a) : 0);
  }
  
  const processModulo = function() {
    var a = pop();
    var b = pop();
    push(a ? b % a : 0);
  }
  
  const processNegation = function() { push(pop() ? 0 : 1); }
  
  const processGreaterThan = function() {
    var a = pop();
    var b = pop();
    push(b > a ? 1 : 0);
  }
  
  const processUnderscore = function() { direction = pop() ? '<' : '>'; }
  
  const processPipe = function() { direction = pop() ? '^' : 'v'; }
  
  const processStringMode = function() {
    moveToNext();
    while (instructions[yPointer][xPointer] !== '"') {
      push(instructions[yPointer][xPointer].charCodeAt(0));
      moveToNext();
    }
  }
  
  const processDuplicateValue = function() { push(stack.length ? stack[stack.length - 1] : 0); }
  
  const processSwap = function() {
    if (stack.length === 1) {
      push(0);
    } else {
      let a = pop();
      let b = pop();
      push(a);
      push(b);
    }
  }
  
  let processInteger = function() { output += pop(); }
  
  let processAscii = function() { output += String.fromCharCode(pop()); }
  
  const processPut = function() {
    let y = pop();
    let x = pop();
    let v = pop();
    instructions[y][x] = String.fromCharCode(v);
  }
  
  const processGet = function() {
    let y = pop();
    let x = pop();
    push(instructions[y][x].charCodeAt(0));
  }
    
  const randomDirection = function() {
    let directions = ['>','<','^','v'];
    return directions[Math.floor(Math.random() * directions.length)];
  }
  
  const changeDirection = function(d) {
    return function() {
      direction = (d === '?') ? randomDirection() : d;
    }
  }
  
  const movements = {
    '>' : moveRight,      
    '<' : moveLeft,
    'v' : moveDown,
    '^' : moveUp   
  }
  
  const dispatcher = {
    '+' : executeAndMove(processPlus),
    '-' : executeAndMove(processMinus),
    '*' : executeAndMove(processTimes),
    '/' : executeAndMove(processDivision),
    '%' : executeAndMove(processModulo),
    '!' : executeAndMove(processNegation),
    '`' : executeAndMove(processGreaterThan),
    '_' : executeAndMove(processUnderscore),
    '|' : executeAndMove(processPipe),
    '"' : executeAndMove(processStringMode),
    ':' : executeAndMove(processDuplicateValue),
    '\\' : executeAndMove(processSwap),
    '$' : executeAndMove(pop),
    '.' : executeAndMove(processInteger),
    ',' : executeAndMove(processAscii),
    '#' : executeAndMove(moveToNext),
    'p' : executeAndMove(processPut),
    'g' : executeAndMove(processGet),
    ' ' : executeAndMove()
  };  
  [0,1,2,3,4,5,6,7,8,9].forEach(function(elem){ dispatcher[elem] = executeAndMove(processNumber(elem));});
  ['<','>','v','^','?'].forEach(function(elem){ dispatcher[elem] = executeAndMove(changeDirection(elem));});
  
  while (instructions[yPointer][xPointer] !== '@') {
    currentInstruction = instructions[yPointer][xPointer];
    dispatcher[currentInstruction]();
  }
  
  return output;
}

module.exports = interpret;
